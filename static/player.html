<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>ç®€åŒ–ç‰ˆ P2P m3u8 æ’­æ”¾å™¨</title>
    <link href="https://vjs.zencdn.net/7.20.3/video-js.css" rel="stylesheet" />
    <script src="https://vjs.zencdn.net/7.20.3/video.min.js"></script>
</head>

<body>

    <h2>ğŸ“º P2P m3u8 æ’­æ”¾å™¨ï¼ˆWebSocket æ¨¡æ‹Ÿ DataChannelï¼‰</h2>
    <video id="my-video" class="video-js vjs-default-skin" controls width="800" height="450">
    </video>
    <button id="requestButton" disabled onclick="requestFile()">è¯·æ±‚æ–‡ä»¶</button>

    <script>
        // å…¨å±€ XHR åŠ«æŒ: æ‹¦æˆª .m3u8/.ts/.vtt çš„è¯·æ±‚ï¼Œé€šè¿‡ P2P DataChannel è·å–
        (function () {
            const origOpen = XMLHttpRequest.prototype.open;
            const origSend = XMLHttpRequest.prototype.send;
            XMLHttpRequest.prototype.open = function (method, url) {
                this._url = url;
                return origOpen.apply(this, arguments);
            };
            XMLHttpRequest.prototype.send = function (body) {
                if (this._url && (this._url.endsWith('.m3u8') || this._url.endsWith('.ts') || this._url.endsWith('.vtt'))) {
                    const xhr = this;
                    const id = Math.random().toString(36).slice(2);
                    console.log("Hijack this url:", this._url, "id:", id)
                    pendingRequests.set(id, { xhr });
                    filePathChannel.send(JSON.stringify({ type: 'hijackReq', ts: xhr._url.split('/').pop(), id }));
                } else {
                    return origSend.apply(this, arguments);
                }
            };
        })();

        // ç”Ÿæˆæ’­æ”¾å™¨
        const player = videojs('my-video', {
            techOrder: ['html5'],
            autoplay: false,
            preload: 'none'
        });

        // è¯·æ±‚æ–‡ä»¶
        function requestFile() {
            player.src({
                src: "/videos/1/1.m3u8", // å¯¹åº”åç«¯ç›®å½•
                type: "application/x-mpegURL",
                tracks: [
                    {
                        kind: "subtitles",
                        src: "/videos/1/1_001.vtt",
                        srclang: "zh",
                        label: "ä¸­æ–‡å­—å¹•",
                        default: true
                    }
                ]
            });

        }

        // ç”Ÿæˆå”¯ä¸€ clientIdï¼ˆæ¯ä¸ª C ç«¯å”¯ä¸€ï¼‰
        function uuidv4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        // ç”Ÿæˆå”¯ä¸€ clientIdï¼ˆæ¯ä¸ª C ç«¯å”¯ä¸€ï¼‰
        const clientId = uuidv4();
        // ä¿¡ä»¤æœåŠ¡å™¨åœ°å€ï¼ˆè¯·æ ¹æ®å®é™…æƒ…å†µä¿®æ”¹ï¼‰
        // const signalingServerUrl = "ws://43.156.74.32:8090/ws";
        // åˆ›å»ºæ–°è¿æ¥
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const signalingServerUrl = `${protocol}//${window.location.host}/ws/client?client_id=${clientId}`;

        let ws;                // WebSocket å¯¹è±¡
        let pc;                // RTCPeerConnection å¯¹è±¡
        const tsFileMap = new Map();            // å› ä¸ºtsæ–‡ä»¶è¿‡å¤§ï¼Œä¸èƒ½é€šè¿‡ä¸€æ¬¡datachannel å‘é€ï¼Œéœ€è¦åˆ†ç‰‡
        let filePathChannel;   // ç”¨äºå‘é€æ–‡ä»¶è·¯å¾„çš„ data channel
        const tsCache = {};
        const pendingRequests = new Map();
        const SERVER_CHUNK_SIZE = 16 * 1024

        // è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨ï¼Œå¹¶æ³¨å†Œèº«ä»½ä¸º C
        function connectSignaling() {
            console.log("æ­£åœ¨è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨...");
            ws = new WebSocket(signalingServerUrl);
            ws.onopen = () => {
                console.log("å·²è¿æ¥ä¿¡ä»¤æœåŠ¡å™¨");
                // è¿æ¥æˆåŠŸåå»ºç«‹ PeerConnection
                createPeerConnection();
            };

            ws.onmessage = (event) => {
                let msg;
                try {
                    msg = JSON.parse(event.data);
                } catch (e) {
                    console.log("ä¿¡ä»¤æ¶ˆæ¯è§£æå¤±è´¥: " + e);
                    return;
                }
                console.log("æ”¶åˆ°WebSocketæ¶ˆæ¯:", msg);
                
                // å¤„ç†ä¿¡ä»¤æ¶ˆæ¯
                if (msg.type === "webrtc_answer") {
                    console.log("æ”¶åˆ° answer");
                    let sdp = "";
                    if (msg.payload && msg.payload.sdp) {
                        sdp = msg.payload.sdp;
                    } else if (msg.sdp) {
                        sdp = msg.sdp;
                    }
                    
                    if (sdp) {
                        const answer = { type: "answer", sdp: sdp };
                        pc.setRemoteDescription(new RTCSessionDescription(answer))
                            .then(() => console.log("å·²è®¾ç½®è¿œç«¯æè¿° (answer)"))
                            .catch(err => console.log("è®¾ç½®è¿œç«¯æè¿°å¤±è´¥: " + err));
                    } else {
                        console.log("answerä¸­æ²¡æœ‰æ‰¾åˆ°sdp:", msg);
                    }
                } else if (msg.type === "ice_candidate") {
                    console.log("æ”¶åˆ° ICE candidate");
                    let candidateObj = null;
                    
                    // å¤„ç†ä¸åŒæ ¼å¼çš„å€™é€‰è€…
                    if (msg.payload && msg.payload.candidate) {
                        candidateObj = JSON.parse(msg.payload.candidate);
                    } else if (msg.candidate) {
                        candidateObj = JSON.parse(msg.candidate);
                    }
                    
                    if (candidateObj) {
                        pc.addIceCandidate(candidateObj)
                            .then(() => console.log("æˆåŠŸæ·»åŠ  ICE candidate"))
                            .catch(err => console.log("æ·»åŠ  ICE candidate å¤±è´¥: " + err));
                    } else {
                        console.log("æ— æ³•è§£æICE candidate:", msg);
                    }
                }
            };

            ws.onerror = (err) => {
                console.log("WebSocket é”™è¯¯: " + err);
            };

            ws.onclose = () => {
                console.log("WebSocket è¿æ¥å·²å…³é—­ï¼Œå°è¯•é‡æ–°è¿æ¥...");
                setTimeout(connectSignaling, 3000); // 3ç§’åå°è¯•é‡è¿
            };
        }

        // åˆ›å»º RTCPeerConnection å¯¹è±¡ï¼Œé…ç½® ICE å¤„ç†ã€æ•°æ®é€šé“ç­‰
        function createPeerConnection() {
            const config = {
                iceServers: [
                    {
                        urls: ["stun:stun.l.google.com:19302"]
                    }
                ]
            };
            console.log("åˆ›å»º PeerConnection...");
            pc = new RTCPeerConnection(config);

            // ICE å€™é€‰ç”Ÿæˆæ—¶
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    const msg = {
                        type: "ice_candidate",
                        payload: JSON.stringify(event.candidate.toJSON()),
                    };
                    console.log("å‘é€ICEå€™é€‰:", msg);
                    ws.send(JSON.stringify(msg));
                } else {
                    console.log("ICE Candidate æ”¶é›†å®Œæˆ");
                }
            };

            // ICE è¿æ¥çŠ¶æ€å˜åŒ–
            pc.oniceconnectionstatechange = () => {
                console.log("ICE connection state: " + pc.iceConnectionState);
                if (pc.iceConnectionState === 'disconnected' ||
                    pc.iceConnectionState === 'failed' ||
                    pc.iceConnectionState === 'closed') {
                    console.log("ICE è¿æ¥å·²æ–­å¼€æˆ–å¤±è´¥ã€‚");
                }
            };

            // PeerConnection çŠ¶æ€å˜åŒ–
            pc.onconnectionstatechange = () => {
                console.log("Connection state change: " + pc.connectionState);
            };

            // åˆ›å»ºæ•°æ®é€šé“ç”¨äºå‘é€æ–‡ä»¶è·¯å¾„ç»™ B
            filePathChannel = pc.createDataChannel("filePathChannel");
            filePathChannel.onopen = () => {
                console.log("filePathChannel å·²æ‰“å¼€");
                // æ•°æ®é€šé“æ‰“å¼€åå¯ç”¨è¯·æ±‚æŒ‰é’®
                document.getElementById("requestButton").disabled = false;
            };
            filePathChannel.onclose = () => {
                console.log("filePathChannel å·²å…³é—­");
                document.getElementById("requestButton").disabled = true;
            };
            filePathChannel.onerror = (e) => {
                console.log("filePathChannel é”™è¯¯: " + e);
            };
            filePathChannel.onmessage = (event) => {
                console.log("æ”¶åˆ°æ¶ˆæ¯ hijack:", event.data)
                const msg = JSON.parse(new TextDecoder().decode(event.data))
                console.log("resp of this msg:", msg.id);

                if (msg.type === 'hijackRespText' && pendingRequests.has(msg.id)) {
                    const { xhr } = pendingRequests.get(msg.id)
                    pendingRequests.delete(msg.id)
                    console.log("å‰ç«¯æ”¶åˆ°çš„m3u8æ–‡ä»¶çš„payload", msg.payload, typeof msg.payload)
                    // å¡«å…… XHR å¹¶è§¦å‘ readyState/onload
                    Object.defineProperty(xhr, 'responseType', { value: '' })
                    Object.defineProperty(xhr, 'responseText', { value: atob(msg.payload) })
                    Object.defineProperty(xhr, 'status', { value: 200 })
                    Object.defineProperty(xhr, 'readyState', { value: 4 })
                    xhr.onreadystatechange && xhr.onreadystatechange()
                    xhr.onload && xhr.onload()
                } else if (msg.type === 'hijackRespData' && pendingRequests.has(msg.id)) {
                    // ä»base64å­—ç¬¦ä¸²è§£ç ä¸ºäºŒè¿›åˆ¶æ•°æ®
                    const binaryString = atob(msg.payload);
                    // åˆ›å»ºä¸€ä¸ªä¸è§£ç åå­—ç¬¦ä¸²é•¿åº¦ç›¸ç­‰çš„Uint8Array
                    const buffer = new Uint8Array(binaryString.length);
                    // å°†æ¯ä¸ªå­—ç¬¦çš„å­—ç¬¦ä»£ç å¤åˆ¶åˆ°Uint8Arrayä¸­
                    for (let i = 0; i < binaryString.length; i++) {
                        buffer[i] = binaryString.charCodeAt(i);
                    }
                    // accumulate chunks and assemble when last slice arrives
                    const totalSlices = msg.totalSliceNum;
                    const totalLength = msg.totalLength;
                    let entry = tsFileMap.get(msg.id);
                    if (!entry) {
                        entry = { buffers: new Array(totalSlices), totalLength };
                        tsFileMap.set(msg.id, entry);
                    }
                    entry.buffers[msg.sliceNum] = buffer;
                    if (msg.sliceNum === totalSlices - 1) {
                        // assemble full file
                        const combined = new Uint8Array(totalLength);
                        for (let i = 0; i < totalSlices; i++) {
                            const chunk = entry.buffers[i];
                            combined.set(chunk, i * SERVER_CHUNK_SIZE);
                        }
                        tsFileMap.delete(msg.id);
                        const { xhr } = pendingRequests.get(msg.id);
                        pendingRequests.delete(msg.id);
                        Object.defineProperty(xhr, 'responseType', { value: 'arraybuffer' });
                        Object.defineProperty(xhr, 'response', { value: combined.buffer });
                        Object.defineProperty(xhr, 'status', { value: 200 });
                        Object.defineProperty(xhr, 'readyState', { value: 4 });
                        xhr.onreadystatechange && xhr.onreadystatechange();
                        xhr.onload && xhr.onload();
                    }
                }
            }

            // åˆ›å»ºæœ¬ç«¯ offerï¼Œå¹¶é€šè¿‡ä¿¡ä»¤é€šé“å‘é€ç»™ B
            pc.createOffer().then(offer => {
                return pc.setLocalDescription(offer);
            }).then(() => {
                console.log("å·²è®¾ç½®æœ¬åœ°æè¿°");
                // æ„é€ ç¬¦åˆæœåŠ¡å™¨æœŸæœ›æ ¼å¼çš„æ¶ˆæ¯
                const msg = { 
                    type: "webrtc_offer", 
                    sdp: pc.localDescription.sdp, 
                    task_id: clientId 
                };
                ws.send(JSON.stringify(msg));
                console.log("offer å‘é€æˆåŠŸï¼ŒclientId:", clientId);
            }).catch(error => {
                console.log("åˆ›å»º offer è¿‡ç¨‹ä¸­å‡ºé”™:" + error);
            });

        }

        connectSignaling();
    </script>
</body>

</html>