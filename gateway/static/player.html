<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MagnetStream Player - åˆ†å¸ƒå¼æµåª’ä½“æ’­æ”¾å™¨</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://vjs.zencdn.net/8.6.1/video-js.css" rel="stylesheet">
    <style>
        :root {
            --netflix-black: #141414;
            --netflix-dark-gray: #181818;
            --netflix-gray: #333333;
            --netflix-light-gray: #757575;
            --netflix-white: #ffffff;
            --netflix-red: #e50914;
            --netflix-red-hover: #f40612;
            --accent-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --success-green: #46d369;
            --warning-orange: #ffa726;
            --error-red: #f44336;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--netflix-black);
            color: var(--netflix-white);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 40px 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .logo {
            font-size: 36px;
            font-weight: 700;
            background: linear-gradient(45deg, var(--netflix-red), #ff6b6b);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 16px;
        }

        .subtitle {
            font-size: 18px;
            color: var(--netflix-light-gray);
            font-weight: 300;
        }

        .player-container {
            background: var(--netflix-dark-gray);
            border-radius: 20px;
            padding: 40px;
            margin-bottom: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .video-wrapper {
            position: relative;
            max-width: 1200px;
            margin: 0 auto;
            border-radius: 16px;
            overflow: hidden;
            background: #000;
        }

        .video-js {
            width: 100%;
            height: 600px;
        }

        .player-controls {
            display: flex;
            justify-content: center;
            gap: 16px;
            margin-top: 24px;
        }

        .control-button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: var(--netflix-red);
            color: white;
        }

        .btn-primary:hover {
            background: var(--netflix-red-hover);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: var(--netflix-gray);
            color: white;
        }

        .btn-secondary:hover {
            background: #404040;
            transform: translateY(-2px);
        }

        .connection-status {
            background: var(--netflix-dark-gray);
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 40px;
            border: 1px solid var(--netflix-gray);
        }

        .status-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--error-red);
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: var(--success-green);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .status-title {
            font-size: 18px;
            font-weight: 600;
        }

        .status-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            color: var(--netflix-light-gray);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid var(--netflix-gray);
        }

        .instructions {
            background: linear-gradient(135deg, rgba(102,126,234,0.1), rgba(118,75,162,0.1));
            border-radius: 16px;
            padding: 32px;
            border: 1px solid rgba(102,126,234,0.2);
        }

        .instructions h3 {
            font-size: 24px;
            margin-bottom: 20px;
            color: var(--netflix-white);
        }

        .instructions ol {
            list-style: none;
            counter-reset: step-counter;
        }

        .instructions li {
            counter-increment: step-counter;
            margin-bottom: 16px;
            padding-left: 40px;
            position: relative;
            font-size: 16px;
            line-height: 1.6;
        }

        .instructions li::before {
            content: counter(step-counter);
            position: absolute;
            left: 0;
            top: 0;
            background: var(--accent-gradient);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 600;
        }

        .url-example {
            background: var(--netflix-gray);
            padding: 12px 16px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            margin: 8px 0;
            border-left: 4px solid var(--netflix-red);
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px 16px;
            }

            .player-container {
                padding: 24px;
                border-radius: 16px;
            }

            .video-js {
                height: 300px;
            }

            .player-controls {
                flex-direction: column;
            }

            .status-details {
                grid-template-columns: 1fr;
            }

            .instructions {
                padding: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="logo">MagnetStream Player</h1>
            <p class="subtitle">åˆ†å¸ƒå¼P2Pæµåª’ä½“æ’­æ”¾å™¨</p>
        </div>

        <div class="player-container">
            <div class="video-wrapper">
                <video 
                    id="videoPlayer" 
                    class="video-js vjs-default-skin" 
                    controls 
                    preload="none"
                    poster="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwMCIgaGVpZ2h0PSI2MDAiIHZpZXdCb3g9IjAgMCAxMjAwIDYwMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjEyMDAiIGhlaWdodD0iNjAwIiBmaWxsPSIjMTQxNDE0Ii8+CjxjaXJjbGUgY3g9IjYwMCIgY3k9IjMwMCIgcj0iNDAiIGZpbGw9IiNlNTA5MTQiLz4KPHN2Zz4K"
                    data-setup="{}"
                >
                    <p class="vjs-no-js">
                        æµè§ˆå™¨ä¸æ”¯æŒHTML5è§†é¢‘æ’­æ”¾ï¼Œè¯· 
                        <a href="https://videojs.com/html5-video-support/" target="_blank">
                            å‡çº§æµè§ˆå™¨
                        </a>
                    </p>
                </video>
            </div>
            
            <div class="player-controls">
                <button class="control-button btn-primary" id="connectBtn">
                    <span id="connectText">å»ºç«‹P2Pè¿æ¥</span>
                    <div class="loading" id="connectLoading" style="display: none;"></div>
                </button>
                <button class="control-button btn-secondary" id="testBtn" disabled style="display: none;">æµ‹è¯•æ’­æ”¾</button>
            </div>
        </div>

        <div class="connection-status">
            <div class="status-header">
                <div class="status-dot" id="statusDot"></div>
                <h3 class="status-title" id="statusTitle">è¿æ¥çŠ¶æ€: æœªè¿æ¥</h3>
            </div>
            <div class="status-details" id="statusDetails">
                <div class="status-item">
                    <span>WebSocketçŠ¶æ€:</span>
                    <span id="wsStatus">æœªè¿æ¥</span>
                </div>
                <div class="status-item">
                    <span>WebRTCçŠ¶æ€:</span>
                    <span id="rtcStatus">æœªè¿æ¥</span>
                </div>
                <div class="status-item">
                    <span>æ•°æ®é€šé“:</span>
                    <span id="dataChannelStatus">æœªæ‰“å¼€</span>
                </div>
                <div class="status-item">
                    <span>å®¢æˆ·ç«¯ID:</span>
                    <span id="clientId">-</span>
                </div>
            </div>
        </div>

        <div class="instructions">
            <h3>ğŸ¬ ä½¿ç”¨è¯´æ˜</h3>
            <ol>
                <li>ç¡®ä¿ç½‘å…³æœåŠ¡å™¨å’Œå·¥ä½œèŠ‚ç‚¹æ­£åœ¨è¿è¡Œ</li>
                <li>ç³»ç»Ÿå°†è‡ªåŠ¨å»ºç«‹P2Pè¿æ¥åˆ°æµåª’ä½“ç½‘ç»œ</li>
                <li>è¿æ¥æˆåŠŸåï¼Œç›´æ¥ç‚¹å‡»æ’­æ”¾å™¨çš„æ’­æ”¾æŒ‰é’®å³å¯æ’­æ”¾</li>
                <li>é€šè¿‡URLå‚æ•°æŒ‡å®šè¦æ’­æ”¾çš„ä»»åŠ¡ID:</li>
            </ol>
            <div class="url-example">
                /player?taskId=your-task-id
            </div>
        </div>
    </div>

    <!-- å¼•å…¥Video.js -->
    <script src="https://vjs.zencdn.net/8.6.1/video.min.js"></script>
    
    <script>
        // å…¨å±€XHRåŠ«æŒï¼šæ‹¦æˆª.m3u8/.ts/.vttçš„è¯·æ±‚ï¼Œé€šè¿‡P2P DataChannelè·å–
        (function () {
            const origOpen = XMLHttpRequest.prototype.open;
            const origSend = XMLHttpRequest.prototype.send;
            
            XMLHttpRequest.prototype.open = function (method, url) {
                this._url = url;
                return origOpen.apply(this, arguments);
            };
            
            XMLHttpRequest.prototype.send = function (body) {
                if (this._url && (this._url.endsWith('.m3u8') || this._url.endsWith('.ts') || this._url.endsWith('.vtt'))) {
                    const xhr = this;
                    const id = Math.random().toString(36).slice(2);
                    console.log("æ‹¦æˆªè¯·æ±‚:", this._url, "ID:", id);
                    
                    pendingRequests.set(id, { xhr });
                    
                    if (filePathChannel && filePathChannel.readyState === 'open') {
                        filePathChannel.send(JSON.stringify({ 
                            type: 'hijackReq', 
                            ts: xhr._url, 
                            id 
                        }));
                    } else {
                        console.error("æ•°æ®é€šé“æœªæ‰“å¼€ï¼Œæ— æ³•å‘é€è¯·æ±‚");
                        // fallbackåˆ°æ™®é€šHTTPè¯·æ±‚
                        return origSend.apply(this, arguments);
                    }
                } else {
                    return origSend.apply(this, arguments);
                }
            };
        })();

        // å…¨å±€å˜é‡
        let socket = null;
        let peerConnection = null;
        let filePathChannel = null;
        let player = null;
        let clientId = 'client-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        
        const tsFileMap = new Map();
        const pendingRequests = new Map();
        const SERVER_CHUNK_SIZE = 16 * 1024;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeApp();
        });

        function initializeApp() {
            updateClientId();
            setupEventListeners();
            initializePlayer();
            
            // æ£€æŸ¥URLå‚æ•°ä¸­çš„taskId
            const urlParams = new URLSearchParams(window.location.search);
            const taskId = urlParams.get('taskId');
            if (taskId) {
                console.log("æ£€æµ‹åˆ°ä»»åŠ¡ID:", taskId);
                // è·å–ä»»åŠ¡ä¿¡æ¯ä»¥ç¡®å®šè¦è¿æ¥çš„workerèŠ‚ç‚¹
                fetchTaskInfo(taskId).then(() => {
                    // ä»»åŠ¡ä¿¡æ¯è·å–å®Œæˆåè‡ªåŠ¨å»ºç«‹P2Pè¿æ¥
                    autoConnect();
                });
            } else {
                // å³ä½¿æ²¡æœ‰taskIdä¹Ÿå°è¯•è‡ªåŠ¨è¿æ¥
                setTimeout(() => autoConnect(), 1000);
            }
        }

        async function fetchTaskInfo(taskId) {
            try {
                // ä»gatewayè·å–æ‰€æœ‰ä»»åŠ¡
                const response = await fetch('/api/tasks');
                const data = await response.json();
                
                if (data.success) {
                    const tasks = data.data.tasks || [];
                    const task = tasks.find(t => t.id === taskId);
                    
                    if (task) {
                        console.log("æ‰¾åˆ°ä»»åŠ¡ä¿¡æ¯:", task);
                        // å­˜å‚¨ä»»åŠ¡ä¿¡æ¯å’ŒworkerèŠ‚ç‚¹ID
                        window.currentTask = task;
                        window.targetWorkerId = task.worker_id;
                        
                        // æ›´æ–°é¡µé¢æ˜¾ç¤º
                        document.querySelector('.subtitle').textContent = 
                            `æ­£åœ¨æ’­æ”¾: ${task.torrent_name || 'æœªçŸ¥ä»»åŠ¡'} (èŠ‚ç‚¹: ${task.worker_id})`;
                        
                        // è‡ªåŠ¨è®¾ç½®æ’­æ”¾æº
                        if (task.status === 'ready' && task.m3u8_path) {
                            const playUrl = `/video/${taskId}/index.m3u8`;
                            player.src({
                                src: playUrl,
                                type: "application/x-mpegURL"
                            });
                            console.log("è‡ªåŠ¨è®¾ç½®æ’­æ”¾æº:", playUrl);
                        }
                    } else {
                        console.error("æœªæ‰¾åˆ°ä»»åŠ¡:", taskId);
                        updateStatus('error', 'ä»»åŠ¡ä¸å­˜åœ¨');
                    }
                }
            } catch (error) {
                console.error("è·å–ä»»åŠ¡ä¿¡æ¯å¤±è´¥:", error);
                updateStatus('error', 'è·å–ä»»åŠ¡ä¿¡æ¯å¤±è´¥');
            }
        }

        function updateClientId() {
            document.getElementById('clientId').textContent = clientId;
        }

        function setupEventListeners() {
            document.getElementById('connectBtn').addEventListener('click', toggleConnection);
            document.getElementById('testBtn').addEventListener('click', testPlayback);
        }
        
        // è‡ªåŠ¨è¿æ¥å‡½æ•°
        async function autoConnect() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log("P2Pè¿æ¥å·²å­˜åœ¨ï¼Œè·³è¿‡è‡ªåŠ¨è¿æ¥");
                return;
            }
            
            console.log("å¼€å§‹è‡ªåŠ¨å»ºç«‹P2Pè¿æ¥...");
            const btn = document.getElementById('connectBtn');
            const btnText = document.getElementById('connectText');
            const loading = document.getElementById('connectLoading');
            
            // æ›´æ–°UIæ˜¾ç¤ºæ­£åœ¨è¿æ¥
            btn.disabled = true;
            btnText.style.display = 'none';
            loading.style.display = 'inline-block';
            
            try {
                await connectToGateway();
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
                btnText.textContent = 'æ–­å¼€è¿æ¥';
                console.log("P2Pè¿æ¥è‡ªåŠ¨å»ºç«‹æˆåŠŸ");
            } catch (error) {
                console.error("è‡ªåŠ¨è¿æ¥å¤±è´¥:", error);
                updateStatus('error', 'è‡ªåŠ¨è¿æ¥å¤±è´¥: ' + error.message);
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                btnText.textContent = 'å»ºç«‹P2Pè¿æ¥';
            } finally {
                btn.disabled = false;
                btnText.style.display = 'inline';
                loading.style.display = 'none';
            }
        }

        function initializePlayer() {
            player = videojs('videoPlayer', {
                techOrder: ['html5'],
                autoplay: false,
                preload: 'none',
                liveui: false,
                fluid: true,
                responsive: true,
                html5: {
                    vhs: {
                        overrideNative: true,
                        enableLowInitialPlaylist: false,
                        smoothQualityChange: false,
                        useBandwidthFromLocalStorage: false
                    }
                }
            });

            player.ready(() => {
                console.log("Video.jsæ’­æ”¾å™¨åˆå§‹åŒ–å®Œæˆ");
                
                // ç›‘å¬æ’­æ”¾å™¨çš„æ’­æ”¾äº‹ä»¶
                player.on('play', () => {
                    console.log("æ’­æ”¾å™¨è¯•å›¾æ’­æ”¾");
                    
                    // æ£€æŸ¥P2Pè¿æ¥æ˜¯å¦å»ºç«‹
                    if (!filePathChannel || filePathChannel.readyState !== 'open') {
                        console.warn("P2Pè¿æ¥æœªå»ºç«‹ï¼Œåœæ­¢æ’­æ”¾");
                        player.pause();
                        updateStatus('error', 'è¯·å…ˆå»ºç«‹P2Pè¿æ¥');
                        return;
                    }
                    
                    // æ£€æŸ¥æ˜¯å¦æœ‰æ’­æ”¾æº
                    if (!player.src()) {
                        const urlParams = new URLSearchParams(window.location.search);
                        const taskId = urlParams.get('taskId');
                        if (taskId) {
                            const playUrl = `/video/${taskId}/index.m3u8`;
                            console.log("è‡ªåŠ¨è®¾ç½®æ’­æ”¾æº:", playUrl);
                            player.src({
                                src: playUrl,
                                type: "application/x-mpegURL"
                            });
                        } else {
                            console.warn("æœªæ‰¾åˆ°taskIdï¼Œæ— æ³•æ’­æ”¾");
                            player.pause();
                            updateStatus('error', 'è¯·æŒ‡å®šè¦æ’­æ”¾çš„ä»»åŠ¡ID');
                        }
                    }
                });
                
                player.on('error', (error) => {
                    console.error("æ’­æ”¾å™¨é”™è¯¯:", error);
                });
            });
        }

        async function toggleConnection() {
            const btn = document.getElementById('connectBtn');
            const btnText = document.getElementById('connectText');
            const loading = document.getElementById('connectLoading');

            if (socket && socket.readyState === WebSocket.OPEN) {
                // æ–­å¼€è¿æ¥
                disconnect();
                btn.classList.remove('btn-secondary');
                btn.classList.add('btn-primary');
                btnText.textContent = 'å»ºç«‹P2Pè¿æ¥';
            } else {
                // å»ºç«‹è¿æ¥
                btn.disabled = true;
                btnText.style.display = 'none';
                loading.style.display = 'inline-block';

                try {
                    await connectToGateway();
                    btn.classList.remove('btn-primary');
                    btn.classList.add('btn-secondary');
                    btnText.textContent = 'æ–­å¼€è¿æ¥';
                } catch (error) {
                    console.error("è¿æ¥å¤±è´¥:", error);
                    updateStatus('error', 'è¿æ¥å¤±è´¥: ' + error.message);
                } finally {
                    btn.disabled = false;
                    btnText.style.display = 'inline';
                    loading.style.display = 'none';
                }
            }
        }

        async function connectToGateway() {
            return new Promise((resolve, reject) => {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/ws/clients?client_id=${clientId}`;
                
                console.log("è¿æ¥åˆ°WebSocket:", wsUrl);
                
                socket = new WebSocket(wsUrl);
                
                socket.onopen = () => {
                    console.log("WebSocketè¿æ¥å·²å»ºç«‹");
                    updateWebSocketStatus('å·²è¿æ¥');
                    createPeerConnection();
                    resolve();
                };

                socket.onmessage = (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        handleWebSocketMessage(message);
                    } catch (error) {
                        console.error("è§£æWebSocketæ¶ˆæ¯å¤±è´¥:", error);
                    }
                };

                socket.onclose = () => {
                    console.log("WebSocketè¿æ¥å·²å…³é—­");
                    updateWebSocketStatus('å·²æ–­å¼€');
                    updateStatus('error', 'WebSocketè¿æ¥å·²æ–­å¼€');
                    
                    // è‡ªåŠ¨é‡è¿
                    setTimeout(() => {
                        if (socket && socket.readyState === WebSocket.CLOSED) {
                            console.log("å°è¯•é‡æ–°è¿æ¥...");
                            connectToGateway().catch(console.error);
                        }
                    }, 5000);
                };

                socket.onerror = (error) => {
                    console.error("WebSocketé”™è¯¯:", error);
                    updateWebSocketStatus('è¿æ¥é”™è¯¯');
                    reject(new Error('WebSocketè¿æ¥å¤±è´¥'));
                };

                // è®¾ç½®è¿æ¥è¶…æ—¶
                setTimeout(() => {
                    if (socket.readyState === WebSocket.CONNECTING) {
                        socket.close();
                        reject(new Error('è¿æ¥è¶…æ—¶'));
                    }
                }, 10000);
            });
        }

        function createPeerConnection() {
            const config = {
                iceServers: [
                    // Google STUNæœåŠ¡å™¨
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' },
                    { urls: 'stun:stun2.l.google.com:19302' },
                    { urls: 'stun:stun3.l.google.com:19302' },
                    { urls: 'stun:stun4.l.google.com:19302' },
                    
                    // å…¶ä»–å…¬å…±STUNæœåŠ¡å™¨
                    { urls: 'stun:stun.cloudflare.com:3478' },
                    { urls: 'stun:stun.nextcloud.com:443' }
                ],
                iceCandidatePoolSize: 10  // å¢åŠ å€™é€‰è€…æ± å¤§å°
            };

            console.log("åˆ›å»ºPeerConnectionï¼Œé…ç½®:", config);
            peerConnection = new RTCPeerConnection(config);

            // åˆ›å»ºæ•°æ®é€šé“
            filePathChannel = peerConnection.createDataChannel("filePathChannel", {
                ordered: true
            });

            setupDataChannel();
            setupPeerConnectionEvents();
            createOffer();
        }

        function setupDataChannel() {
            filePathChannel.onopen = () => {
                console.log("æ•°æ®é€šé“å·²æ‰“å¼€");
                updateDataChannelStatus('å·²æ‰“å¼€');
                updateStatus('success', 'P2Pè¿æ¥å·²å»ºç«‹');
                document.getElementById('testBtn').disabled = false;
                
                // P2Pè¿æ¥å»ºç«‹å®Œæˆåï¼Œå¦‚æœæ’­æ”¾å™¨å·²ç»æœ‰æºï¼Œåˆ™å¯ä»¥ç›´æ¥æ’­æ”¾
                const urlParams = new URLSearchParams(window.location.search);
                const taskId = urlParams.get('taskId');
                if (taskId && player.src()) {
                    console.log("P2Pè¿æ¥å·²å»ºç«‹ï¼Œæ’­æ”¾å™¨å·²å‡†å¤‡å°±ç»ª");
                }
            };

            filePathChannel.onclose = () => {
                console.log("æ•°æ®é€šé“å·²å…³é—­");
                updateDataChannelStatus('å·²å…³é—­');
                document.getElementById('testBtn').disabled = true;
            };

            filePathChannel.onerror = (error) => {
                console.error("æ•°æ®é€šé“é”™è¯¯:", error);
                updateDataChannelStatus('é”™è¯¯');
            };

            filePathChannel.onmessage = (event) => {
                handleDataChannelMessage(event);
            };
        }

        function setupPeerConnectionEvents() {
            peerConnection.onicecandidate = (event) => {
                if (event.candidate && socket && socket.readyState === WebSocket.OPEN) {
                    const message = {
                        type: "ice_candidate",
                        payload: {
                            candidate: event.candidate.candidate,
                            session_id: clientId,
                            is_client: true
                        }
                    };
                    socket.send(JSON.stringify(message));
                    console.log("å‘é€ICEå€™é€‰è€…:", event.candidate.candidate);
                } else if (!event.candidate) {
                    console.log("ICEå€™é€‰è€…æ”¶é›†å®Œæˆ");
                }
            };

            peerConnection.onconnectionstatechange = () => {
                const state = peerConnection.connectionState;
                console.log("WebRTCè¿æ¥çŠ¶æ€:", state);
                updateRTCStatus(state);
                
                if (state === 'connected') {
                    updateStatus('success', 'WebRTCè¿æ¥å·²å»ºç«‹');
                } else if (state === 'failed') {
                    updateStatus('error', 'WebRTCè¿æ¥å¤±è´¥ - å¯èƒ½çš„ç½‘ç»œé—®é¢˜');
                    console.error("WebRTCè¿æ¥å¤±è´¥ï¼Œå¯èƒ½åŸå› ï¼š");
                    console.error("1. ç½‘ç»œç¯å¢ƒé™åˆ¶ï¼ˆå¦‚æ‰‹æœºçƒ­ç‚¹çš„NATï¼‰");
                    console.error("2. STUNæœåŠ¡å™¨æ— æ³•è®¿é—®");
                    console.error("3. é˜²ç«å¢™é˜»æ­¢UDPæµé‡");
                    console.error("å»ºè®®ï¼šå°è¯•åœ¨æ›´ç¨³å®šçš„ç½‘ç»œç¯å¢ƒä¸‹æµ‹è¯•");
                } else if (state === 'disconnected') {
                    updateStatus('error', 'WebRTCè¿æ¥å·²æ–­å¼€');
                }
            };

            peerConnection.oniceconnectionstatechange = () => {
                const iceState = peerConnection.iceConnectionState;
                console.log("ICEè¿æ¥çŠ¶æ€:", iceState);
                
                if (iceState === 'failed') {
                    console.error("ICEè¿æ¥å¤±è´¥ - ç½‘ç»œç©¿é€é—®é¢˜");
                    console.error("å½“å‰ç½‘ç»œå¯èƒ½ä¸æ”¯æŒP2Pè¿æ¥");
                    console.error("æ‰‹æœºçƒ­ç‚¹é€šå¸¸æœ‰ä¸¥æ ¼çš„NATé™åˆ¶");
                }
            };

            peerConnection.onicegatheringstatechange = () => {
                console.log("ICEæ”¶é›†çŠ¶æ€:", peerConnection.iceGatheringState);
            };
        }

        async function createOffer() {
            if (!window.targetWorkerId) {
                console.error("æœªæŒ‡å®šç›®æ ‡workerèŠ‚ç‚¹");
                updateStatus('error', 'æœªæ‰¾åˆ°ç›®æ ‡workerèŠ‚ç‚¹');
                return;
            }

            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                const message = {
                    type: "webrtc_offer",
                    payload: {
                        sdp: offer.sdp,
                        client_id: clientId,
                        session_id: clientId,
                        worker_id: window.targetWorkerId  // æŒ‡å®šç›®æ ‡workerèŠ‚ç‚¹
                    }
                };

                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify(message));
                    console.log("å‘é€WebRTC Offeråˆ°worker:", window.targetWorkerId);
                }
            } catch (error) {
                console.error("åˆ›å»ºOfferå¤±è´¥:", error);
                updateStatus('error', 'åˆ›å»ºWebRTCè¿æ¥å¤±è´¥');
            }
        }

        function handleWebSocketMessage(message) {
            console.log("æ”¶åˆ°WebSocketæ¶ˆæ¯:", message);

            switch (message.type) {
                case 'webrtc_answer':
                    console.log("æ”¶åˆ°WebRTC Answer:", message.payload);
                    handleWebRTCAnswer(message.payload);
                    break;
                case 'ice_candidate':
                    console.log("æ”¶åˆ°ICEå€™é€‰è€…:", message.payload);
                    handleICECandidate(message.payload);
                    break;
                default:
                    console.log("æœªå¤„ç†çš„æ¶ˆæ¯ç±»å‹:", message.type);
            }
        }

        async function handleWebRTCAnswer(payload) {
            if (!peerConnection || !payload.sdp) return;

            try {
                const answer = new RTCSessionDescription({
                    type: 'answer',
                    sdp: payload.sdp
                });

                await peerConnection.setRemoteDescription(answer);
                console.log("è®¾ç½®è¿œç¨‹æè¿°æˆåŠŸ");
            } catch (error) {
                console.error("è®¾ç½®è¿œç¨‹æè¿°å¤±è´¥:", error);
            }
        }

        async function handleICECandidate(payload) {
            if (!peerConnection || !payload.candidate) return;

            try {
                const candidate = new RTCIceCandidate({
                    candidate: payload.candidate,
                    sdpMid: '0',
                    sdpMLineIndex: 0
                });

                await peerConnection.addIceCandidate(candidate);
                console.log("æ·»åŠ ICEå€™é€‰è€…æˆåŠŸ");
            } catch (error) {
                console.error("æ·»åŠ ICEå€™é€‰è€…å¤±è´¥:", error);
            }
        }

        function handleDataChannelMessage(event) {
            try {
                const msg = JSON.parse(new TextDecoder().decode(event.data));
                
                if (msg.type === 'hijackRespText' && pendingRequests.has(msg.id)) {
                    handleTextResponse(msg);
                } else if (msg.type === 'hijackRespData' && pendingRequests.has(msg.id)) {
                    handleBinaryResponse(msg);
                }
            } catch (error) {
                console.error("å¤„ç†æ•°æ®é€šé“æ¶ˆæ¯å¤±è´¥:", error);
            }
        }

        function handleTextResponse(msg) {
            const totalSlices = msg.totalSliceNum;
            const totalLength = msg.totalLength;
            let entry = tsFileMap.get(msg.id);
            
            if (!entry) {
                entry = { buffers: new Array(totalSlices), totalLength, isText: true };
                tsFileMap.set(msg.id, entry);
            }
            
            // è§£ç base64æ•°æ®
            const binaryString = atob(msg.payload);
            const buffer = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                buffer[i] = binaryString.charCodeAt(i);
            }
            entry.buffers[msg.sliceNum] = buffer;
            
            // æ£€æŸ¥æ˜¯å¦æ”¶åˆ°æ‰€æœ‰åˆ†ç‰‡
            if (msg.sliceNum === totalSlices - 1) {
                // ç»„è£…å®Œæ•´æ–‡ä»¶
                const combined = new Uint8Array(totalLength);
                for (let i = 0; i < totalSlices; i++) {
                    const chunk = entry.buffers[i];
                    combined.set(chunk, i * SERVER_CHUNK_SIZE);
                }
                
                const text = new TextDecoder().decode(combined);
                
                tsFileMap.delete(msg.id);
                const { xhr } = pendingRequests.get(msg.id);
                pendingRequests.delete(msg.id);
                
                // è®¾ç½®XHRå“åº”
                Object.defineProperty(xhr, 'responseType', { value: '' });
                Object.defineProperty(xhr, 'responseText', { value: text });
                Object.defineProperty(xhr, 'status', { value: 200 });
                Object.defineProperty(xhr, 'readyState', { value: 4 });
                
                xhr.onreadystatechange && xhr.onreadystatechange();
                xhr.onload && xhr.onload();
            }
        }

        function handleBinaryResponse(msg) {
            const totalSlices = msg.totalSliceNum;
            const totalLength = msg.totalLength;
            let entry = tsFileMap.get(msg.id);
            
            if (!entry) {
                entry = { buffers: new Array(totalSlices), totalLength };
                tsFileMap.set(msg.id, entry);
            }
            
            // è§£ç base64æ•°æ®
            const binaryString = atob(msg.payload);
            const buffer = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                buffer[i] = binaryString.charCodeAt(i);
            }
            entry.buffers[msg.sliceNum] = buffer;
            
            // æ£€æŸ¥æ˜¯å¦æ”¶åˆ°æ‰€æœ‰åˆ†ç‰‡
            if (msg.sliceNum === totalSlices - 1) {
                // ç»„è£…å®Œæ•´æ–‡ä»¶
                const combined = new Uint8Array(totalLength);
                for (let i = 0; i < totalSlices; i++) {
                    const chunk = entry.buffers[i];
                    combined.set(chunk, i * SERVER_CHUNK_SIZE);
                }
                
                tsFileMap.delete(msg.id);
                const { xhr } = pendingRequests.get(msg.id);
                pendingRequests.delete(msg.id);
                
                // è®¾ç½®XHRå“åº”
                Object.defineProperty(xhr, 'responseType', { value: 'arraybuffer' });
                Object.defineProperty(xhr, 'response', { value: combined.buffer });
                Object.defineProperty(xhr, 'status', { value: 200 });
                Object.defineProperty(xhr, 'readyState', { value: 4 });
                
                xhr.onreadystatechange && xhr.onreadystatechange();
                xhr.onload && xhr.onload();
            }
        }

        function testPlayback() {
            const urlParams = new URLSearchParams(window.location.search);
            const taskId = urlParams.get('taskId') || 'demo';
            
            const testUrl = `/video/${taskId}/index.m3u8`;
            console.log("æµ‹è¯•æ’­æ”¾:", testUrl);
            
            player.src({
                src: testUrl,
                type: "application/x-mpegURL"
            });
            
            player.ready(() => {
                player.play().catch(error => {
                    console.error("æ’­æ”¾å¤±è´¥:", error);
                });
            });
        }

        function disconnect() {
            if (filePathChannel) {
                filePathChannel.close();
                filePathChannel = null;
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            if (socket) {
                socket.close();
                socket = null;
            }
            
            updateStatus('error', 'å·²æ–­å¼€è¿æ¥');
            updateWebSocketStatus('æœªè¿æ¥');
            updateRTCStatus('disconnected');
            updateDataChannelStatus('æœªæ‰“å¼€');
            
            document.getElementById('testBtn').disabled = true;
        }

        // çŠ¶æ€æ›´æ–°å‡½æ•°
        function updateStatus(type, message) {
            const dot = document.getElementById('statusDot');
            const title = document.getElementById('statusTitle');
            
            dot.className = 'status-dot' + (type === 'success' ? ' connected' : '');
            title.textContent = `è¿æ¥çŠ¶æ€: ${message}`;
        }

        function updateWebSocketStatus(status) {
            document.getElementById('wsStatus').textContent = status;
        }

        function updateRTCStatus(status) {
            const statusMap = {
                'new': 'æ–°å»º',
                'connecting': 'è¿æ¥ä¸­',
                'connected': 'å·²è¿æ¥',
                'disconnected': 'å·²æ–­å¼€',
                'failed': 'å¤±è´¥',
                'closed': 'å·²å…³é—­'
            };
            document.getElementById('rtcStatus').textContent = statusMap[status] || status;
        }

        function updateDataChannelStatus(status) {
            document.getElementById('dataChannelStatus').textContent = status;
        }
    </script>
</body>
</html>